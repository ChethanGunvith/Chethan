---
title: Kotlin transformation function
tags: kotlin
article_header:
  type: cover
  image:
---

In Kotlin, transformation functions are used to convert or modify data in a variety of ways. These functions are typically applied to collections, sequences, or flows, allowing you to perform operations such as mapping, filtering, sorting, and more. Here are some commonly used transformation functions:

1. **map**: Transforms each element in a collection, sequence, or flow according to a given transformation function.

    ```kotlin
    val list = listOf(1, 2, 3)
    val doubledList = list.map { it * 2 } // [2, 4, 6]
    ```

2. **flatMap**: Transforms each element into an iterable, and then flattens the resulting iterables into a single collection, sequence, or flow.

    ```kotlin
    val nestedList = listOf(listOf(1, 2), listOf(3, 4))
    val flattenedList = nestedList.flatMap { it } // [1, 2, 3, 4]
    ```

3. **filter**: Filters elements based on a given predicate function.

    ```kotlin
    val list = listOf(1, 2, 3, 4, 5)
    val evenNumbers = list.filter { it % 2 == 0 } // [2, 4]
    ```

4. **sortedBy**: Sorts elements based on the result of a transformation function applied to each element.

    ```kotlin
    val list = listOf("banana", "apple", "orange")
    val sortedList = list.sortedBy { it.length } // [apple, orange, banana]
    ```

5. **groupBy**: Groups elements by the result of a transformation function.

    ```kotlin
    val list = listOf("apple", "banana", "orange")
    val groupedByLength = list.groupBy { it.length } // {5=[apple], 6=[banana, orange]}
    ```

6. **distinct**: Returns a collection, sequence, or flow containing only distinct elements.

    ```kotlin
    val list = listOf(1, 2, 2, 3, 3, 3)
    val distinctNumbers = list.distinct() // [1, 2, 3]
    ```

7. **associateBy**: Creates a map where keys are generated by a key selector function and values are the elements themselves.

    ```kotlin
    data class Person(val name: String, val age: Int)
    val people = listOf(Person("Alice", 30), Person("Bob", 25))
    val mapByName = people.associateBy { it.name } // {Alice=Person(name=Alice, age=30), Bob=Person(name=Bob, age=25)}
    ```

8. **fold**: Accumulates the results of applying an operation sequentially to each element and an accumulator value.

    ```kotlin
    val list = listOf(1, 2, 3, 4, 5)
    val sum = list.fold(0) { acc, value -> acc + value } // 15
    ```

9. **take**: Returns the first n elements from a collection, sequence, or flow.

    ```kotlin
    val list = listOf(1, 2, 3, 4, 5)
    val firstThree = list.take(3) // [1, 2, 3]
    ```

10. **zip**: Combines elements from two or more collections, sequences, or flows into pairs or tuples.

    ```kotlin
    val numbers = listOf(1, 2, 3)
    val letters = listOf("A", "B", "C")
    val pairs = numbers.zip(letters) // [(1, A), (2, B), (3, C)]
    ```

11. **flatMapConcat**: Maps each value to a flow and concatenates the resulting flows.

12. **flatMapMerge**: Maps each value to a flow and merges the resulting flows concurrently.

13. **distinctUntilChanged**: Filters out consecutive duplicate values emitted by the flow, allowing only distinct consecutive values.

14. **scan**: Accumulates values emitted by the flow over time, applying a function to each new value and the previously accumulated value.

15. **debounce**: Delays emissions from the upstream flow until a specified period of time has passed without any new emissions.

These functions cover a wide range of common data manipulation tasks in Kotlin and are frequently used in various programming scenarios.
